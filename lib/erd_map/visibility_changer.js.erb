(function() {
  const layoutsByChunk = <%= layouts_by_chunk.to_json.html_safe %>
  const chunkedNodes = <%= chunked_nodes.to_json.html_safe %>
  const VISIBLE = <%= visible %>
  const TRANSLUCENT = <%= translucent %>

  const nodesWithChunkIndex = {}
  chunkedNodes.forEach((chunk, i) => {
    chunk.forEach((n) => { nodesWithChunkIndex[n] = i })
  })

  const nodeSource = graphRenderer.node_renderer.data_source
  const edgeSource = graphRenderer.edge_renderer.data_source
  const nodesAlpha = nodeSource.data["alpha"]
  const nodesIndex = nodeSource.data["index"]
  const nodesX = nodeSource.data["x"]
  const nodesY = nodeSource.data["y"]
  const startEdges = edgeSource.data["start"]
  const targetEdges= edgeSource.data["end"]
  const edgesAlpha = edgeSource.data["alpha"]

  let currentRange = cb_obj.end - cb_obj.start
  if (window.stableRange === undefined) { window.stableRange = currentRange }
  if (window.displayChunksCount === undefined) { window.displayChunksCount = 0 }
  if (window.zoomTimeout !== undefined) { clearTimeout(window.zoomTimeout) }

  const previousDisplayChunksCount = window.displayChunksCount

  window.zoomTimeout = setTimeout(handleZoomTimeout, 200)

  function handleZoomTimeout() {
    const stableRange = window.stableRange
    let displayChunksCount = window.displayChunksCount
    // distance < 0: Zoom in
    // 0 < distance: Zoom out
    let distance = currentRange - stableRange
    const threshold = stableRange * 0.1
    if (Math.abs(distance) >= Math.abs(threshold)) {
      if (distance < 0) { // Zoom in
        displayChunksCount = Math.min(displayChunksCount + 1, chunkedNodes.length - 1)
      } else { // Zoom out
        displayChunksCount = Math.max(displayChunksCount - 1, 0)
      }
    }
    window.displayChunksCount = displayChunksCount
    window.stableRange = currentRange

    if (displayChunksCount === previousDisplayChunksCount) { return }

    const selectedLayout = layoutsByChunk[displayChunksCount]
    nodesIndex.forEach((nodeName, i) => {
      const chunkIndex = nodesWithChunkIndex[nodeName]
      if (selectedLayout[nodeName]) {
        const [newX, newY] = selectedLayout[nodeName]
        nodesX[i] = newX
        nodesY[i] = newY
      }
      nodesAlpha[i] = chunkIndex <= displayChunksCount ? VISIBLE : TRANSLUCENT
    })

    startEdges.forEach((source, i) => {
      const target = targetEdges[i]
      const sourceIndex = nodesWithChunkIndex[source]
      const targetIndex = nodesWithChunkIndex[target]

      if (
        sourceIndex <= displayChunksCount &&
        targetIndex <= displayChunksCount &&
        selectedLayout[source] !== undefined &&
        selectedLayout[target] !== undefined
      ) {
        edgesAlpha[i] = VISIBLE
      } else {
        edgesAlpha[i] = TRANSLUCENT
      }
    })

    const mouseX = window.lastMouseX ?? 0
    const mouseY = window.lastMouseY ?? 0

    if (window.previousShiftX === undefined) { window.previousShiftX = 0 }
    if (window.previousShiftY === undefined) { window.previousShiftY = 0 }

    let closestNodeName
    let minmumDistance = Infinity
    const previousLayout = layoutsByChunk[previousDisplayChunksCount]
    nodesIndex.forEach((nodeName, _i) => {
      if (previousLayout[nodeName] === undefined) { return }
      const nodeX = previousLayout[nodeName][0] + window.previousShiftX
      const nodeY = previousLayout[nodeName][1] + window.previousShiftY
      const dx = nodeX - mouseX
      const dy = nodeY - mouseY
      const distance = dx * dx + dy * dy
      if (distance < minmumDistance) {
        minmumDistance = distance
        closestNodeName = nodeName
      }
    })

    if (closestNodeName && selectedLayout[closestNodeName]) {
      const closestNode = selectedLayout[closestNodeName]
      window.previousShiftX = mouseX - closestNode[0]
      window.previousShiftY = mouseY - closestNode[1]
      nodesIndex.forEach((_nodeName, i) => {
        nodesX[i] += window.previousShiftX
        nodesY[i] += window.previousShiftY
      })
    }

    nodeSource.change.emit()
    edgeSource.change.emit()

    const newGraphLayout = {}
    nodesIndex.forEach((nodeName, i) => {
      newGraphLayout[nodeName] = [nodesX[i], nodesY[i]]
    })
    layoutProvider.graph_layout = newGraphLayout
    layoutProvider.change.emit()
  }
})()
